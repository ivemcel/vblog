Redis(Remote Dictionary Server)远程字典服务器是一个用C语言编写的、开源的、基于内存运行并支持持久化的、高性能的NoSQL数据库。Redis中的数据大部分数据都是存储中内存中的，适合存储频繁访问、数据量小的数据。
Redis客户端是一个程序，通过网络连接到Redis服务器，从而实现跟 Redis服务器的交互。Redis客户端发送命令，同时显示Redis服务器的处理结果。redis-cli（Redis Command Line Interface）是Redis自带的基于命令行的Redis客户端，用于与服务端交互，我们可以使用该客户端来执行redis的各种命令。
Redis默认使用16个库，从0到15。在redis.conf文件中databases 16，可以修改数据库的个数，理论上可以配置无限多个。
**Redis为什么这么快？**

- 基于内存：redis使用内存存储数据，读写速度快。
- 单线程实现（ Redis 6.0以前）：redis的命令执行核心模块是单线程的，避免了多个线程切换和锁资源竞争的开销。
- 高效的数据结构：redis的数据结构非常简单，操作节省时间

redis的命令执行核心模块是单线程的，但是整个redis实例并不全是单线程的。redis的作者说在实际的应用场景中，很少遇到速度瓶颈在于CPU的情况，往往是网络的带宽和内存的大小限制了redis的性能。
**Redis和memcached的区别？**

- 最主要的区别，Redis提供多种数据类型，而memcached只能存储字符串。
- redis支持持久化，而memcachedd没有持久化策略。这就决定了redis具备一定的容灾机制，但是memcached没有。
### 数据类型
#### 字符串String
String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值。value其实不仅是字符串，也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。
Redis是用C语言实现的，但是C语言的字符串存在如下缺陷：

- C语言获取字符串长度的时间复杂度是 O(N)。遍历字符数组中的每一个字符，并进行计数，等遇到字符为 "\0"后，就会停止遍历，返回已经统计到的字符个数。
- 字符串的结尾是以 "\0"字符标识，字符串里面不能包含有 "\0"字符，因此不能保存二进制数据。
- 字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止。

**底层实现：**redis作者封装了一个名为**简单动态字符串SDS**的数据结构来表示字符串。SDS结构实现：Redis3.0中，SDS中有int len、int free、char buf[]三个属性。len保存字符串的长度，free表示buf数组中未使用的字节数量，buf数组则是保存字符串的每一个字符元素。相比C语言的字符串：

- SDS可以在O(1)时间获取字符串长度；
- 二进制安全，SDS不需要用"\0"字符来标识字符串结尾，通过len成员变量来记录长度，所以可存储包含 "\0"的数据。
- SDS先判断空间是否满足要求，若是空间不够，就会进行相应的空间扩展，所以不会出现缓冲区溢出的情况
- 采用预分配冗余空间的方式来减少内存的频繁分配。预分配原则：当修改字符串后的长度len小于1MB，就会预分配和len一样长度的空间，即len=free；若是len大于1MB，free分配的空间大小就为1MB。

**应用场景：**

- 常规计数：Redis处理命令是单线程，所以执行命令的过程是原子的，因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。
- 缓存对象
#### 列表List
Redis的列表底层是双向链表。list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。
```c
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661480318465-b005eb17-7a6d-4bd3-bee2-5faf2dbca0bd.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=191&id=ufcdda756&margin=%5Bobject%20Object%5D&name=image.png&originHeight=512&originWidth=1449&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36901&status=done&style=none&taskId=u29743ff0-2e25-4002-9201-b704af55f42&title=&width=540.5)
Redis 实现的**链表优点**：

- listNode链表节点的结构里带有 prev 和 next 指针，获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表；
- list 结构因为提供了表头指针 head 和表尾节点 tail，所以获取链表的表头节点和表尾节点的时间复杂度只需O(1)；
- list 结构因为提供了链表节点数量 len，所以获取链表中的节点数量的时间复杂度只需O(1)；
- listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此链表节点可以保存各种不同类型的值；

**链表缺陷：**链表每个节点之间的内存都是不连续的，意味着无法很好利用CPU缓存。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。
Redis3.0中，List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。
**应用场景**

1. **发布订阅模式**：redis提供主题订阅模式来实现多个消费者的情况。一个客户端可以同时订阅多个频道，例如

`subscribe channel1 channel2`。多个客户端可以同时订阅同一个频道（多个消费者，多个生产者）。通过publish channel message命令来向频道中发送信息，在对应的收听客户端能够看到信息。
```c
publish channel1 "hello channel1!"
publish channel2 "hello channel2~"
```
主题订阅模式可以轻松实现简单的消息队列，也可以实现多个消费者和多个生产者的消息传递。但是存在一个问题，消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。

2. **使用Stream实现消息队列**

生产者通过 XADD 命令插入一条消息：
```bash
# * 表示让Redis为插入的数据自动生成一个全局唯一的ID
# 往名称为mq的消息队列中插入一条消息，消息的键是name，值是hello
XADD mq * name hello
# 插入成功后会返回全局唯一的 ID
"1654254953808-0"  
```
消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息ID，并从**这个消息ID的下一条消息**开始进行读取。使用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。
**基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？**
Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。

3. **使用List消息队列**

List 可以使用 LPUSH + RPOP （或者RPUSH+LPOP）命令实现消息队列。

- 生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果key不存在则会创建一个空的队列再插入消息。
- 消费者使用RPOP key依次读取队列的消息，先进先出。

在生产者往List中写入数据时，List并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用RPOP命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。
为了解决这个问题，Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。
**Redis中用来执行命令处理数据的线程只有一个，**`**brpop**`**和**`**blpop**`**这种阻塞命令如何实现的呢？
**redis在blpop命令处理过程时，首先会去查找key对应的list，如果存在，则pop出数据响应给客户端。否则将对应的key push到blocking_keys数据结构当中，对应的value是被阻塞的client。当下次push命令发出时，服务器检查blocking_keys当中是否存在对应的key，如果存在，则将key添加到ready_keys链表当中，同时将value插入链表当中并响应客户端。如果不存在，到时间自动返回。总结来讲，Redis就是使用事件循环和两个链表结构`reday_keys`和`blocking_keys`来处理阻塞事件的。
**如何保证消息可靠性？**
List类型提供了BRPOPLPUSH命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。
#### 哈希Hash
哈希表是一种保存键值对（key-value）的数据结构。哈希表中的每一个key都是独一无二的，程序可以根据key查找到与之关联的 value，或者通过key来更新value，又或者根据key来删除整个key-value等等。 
哈希表优点在于，它能以 O(1) 的复杂度快速查询数据。因为哈希表实际上是数组，通过Hash函数计算key的Hash值，就能定位数据在表中的位置。在哈希表大小固定的情况下，随着数据不断增多，那么哈希冲突的可能性也会越高。Redis采用了「链式哈希」来解决哈希冲突，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链表，以便这些数据在表中仍然可以被查询到。 
Redis 的哈希表结构如下：
```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值
    unsigned long sizemask;
    //该哈希表已有的节点数量
    unsigned long used;
} dictht;
```
哈希表是一个数组（dictEntry **table），数组中每个元素都是指向一个哈希表节点结构（dictEntry）的指针；dictEntry结构里存放了key和value 指针，key指针指向String对象，value指针可以指向 String 对象，也可以指向集合类型的对象。
```c
typedef struct dictEntry {
    //键值对中的键
    void *key;
    //键值对中的值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```
dictEntry还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题。但是随着链表长度的增加，查询这一位置上的数据的耗时就会增加，时间复杂度是O(n)。
dictEntry 结构中的值v是一个「联合体 v」定义的，它可以是一个指向实际值的指针，或者是一个无符号/有符号的64位整数或double 类的值。这么当值v是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。
**应用场景：**缓存对象：Hash 类型的 （key，field， value）的结构与对象的（对象id，属性，值）的结构相似，可以用来存储对象。一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。
#### rehash和渐进式rehash
Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表，用于rehash操作。
```c
typedef struct dict {
    …
    //两个Hash表，交替使用，用于rehash操作
    dictht ht[2]; 
    …
} dict;
```
在正常服务请求阶段，插入的数据，都会写入到「哈希表1」，此时的「哈希表2」 并没有被分配空间。
随着数据的增多，当满足以下条件时会触发rehash操作。其中，负载因子=哈希表已保存节点数量/哈希表大小。

- 当负载因子大于等于1 ，并且Redis没有执行bgsave命令或者 bgrewiteaof 命令，也就是没有执行RDB快照或没有进行 AOF重写的时候，就会进行rehash操作。
- 当负载因子大于等于5时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB快照或AOF重写，都会强制进行 rehash操作。

**rehash操作过程：**

- 给哈希表2分配空间，一般会比哈希表1大2倍；
- 将哈希表1的数据迁移到哈希表2中；
- 迁移完成后，哈希表1的空间会被释放，并把哈希表2设置为哈希表1，然后在哈希表 2新创建一个空白的哈希表，为下次 rehash做准备。

在数据迁移过程中，如果哈希表1的数据量非常大，那么在迁移至哈希表2的时候，因为会涉及大量的数据拷贝，影响Redis性能。
![](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661483335537-3832f32f-695d-4034-8fed-b7ac80a63285.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&height=262&id=hYKiX&originHeight=699&originWidth=1502&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf504af20-655a-472e-a78a-64118cdb3f0&title=&width=563)
**渐进式rehash**也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。步骤如下：

- 给哈希表2分配空间；
- 在rehash进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将哈希表1中索引位置上的所有 key-value 迁移到哈希表2上；
- 随着处理客户端发起的哈希表操作请求数量越多，最终会把哈希表1的所有 key-value 迁移到哈希表2，从而完成 rehash操作。
这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。

在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。

- 查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到；
- 新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表
#### 集合Set
**底层实现：**整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。
**应用场景：**

- 点赞：Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。
- 共同关注：Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。key 可以是用户id，value 则是已关注的公众号的id。
- 抽奖活动：存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。
集合是无序、不可重复、支持并交差等操作。注意：Set的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致Redis实例阻塞。
#### 有序集合Zset
Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值）。对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。
**Zset的底层数据结构是由压缩列表或跳表实现的：**

- 如果有序集合的元素个数小于128个，并且每个元素的值小于64字节时，Redis会使用压缩列表作为Zset类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis会使用跳表作为Zset类型的底层数据结构；
```c
typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
```
**应用场景：**

- 排行榜：zset用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。
- 电话、姓名排序：使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序
##### 压缩列表
压缩列表是一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484072961-e72b795a-fc2b-46f2-b215-a293ef7a5908.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=KZh4v&name=image.png&originHeight=302&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26945&status=done&style=none&taskId=u1a373e24-f8ab-4d06-9c93-00d22814d7f&title=&width=481)
压缩列表数据结构头部有三个字段：

- zlbytes，记录整个压缩列表占用的内存字节数；
-  zltail，记录压缩列表「尾部」节点距离起始地址有多少字节，也就是列表尾的偏移量；
- zllen，记录压缩列表包含的节点数量；

可以通过头部三个字段的长度直接定位第一个节点和最后一个节点。对于其他元素，只能逐个查找，复杂度是O(N)，因此压缩列表不适合保存过多的元素。尾部有一个zlend字段，标记压缩列表的结束点，固定值 0xFF（十进制255）。
压缩列表节点包含三部分内容：

- prevlen记录了「前一个节点」的长度；
- encoding记录了当前节点实际数据的类型以及长度；
- data记录了当前节点的实际数据；

当往压缩列表中插入数据时，压缩列表会根据数据是字符串还是整数，以及数据的大小，使用不同空间大小的 prevlen 和 encoding 保存信息，这种根据数据大小和类型进行不同的空间大小分配的设计思想，可以大大节省内存。压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。
##### 跳表
跳表是在有序链表基础上改进而来的一种多层有序链表。在一个有序链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点或者这个数据不存在，时间复杂度为O(n)。
假如让链表中的每相邻两个节点再增加一个指针，指向下下个节点，这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。现在我们查找数据的时候，先沿着上层这个新链表进行查找。当碰到比待查数据大的节点时，再回到第一层原始链表中进行查找。在上层链表查找过程中，需要比较的节点数大约只有原来的一半，这样就提高了查询速度。
跳表思想是除了底层第一层链表外，向上产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点，而且越高层的链表跳过的节点越多。这就我们在查找数据时，先在高层链表中进行查找，然后逐层降低，最终降到第1层链表来精确地定位数据位置。在这个过程中，我们跳过了一些节点，加快了查找速度，提高了查询效率。
跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。
```c
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;
```
在跳表节点中，用sds类型的ele变量保存元素，double类型的score变量元素的权重。每个跳表节点还有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。
跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的zskiplistLevel 结构体类型的 level 数组。
level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度用来记录两个节点之间的距离。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484415917-28b0d6fb-b7b8-49fa-bf3b-a3279baaebc6.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=159&id=u591a590b&name=image.png&originHeight=317&originWidth=1947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55854&status=done&style=none&taskId=u2577bda5-c9ba-4f38-aa80-50db51ae5e7&title=&width=973.5)
#### 三种特殊的数据类型

- HyperLogLog，用于基数统计，结果不是精确的，但是每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64个不同元素的基数。
- 地理位置GEO，存储地理位置信息，并对存储的信息进行操作
- 位图bitmap，本质上是字符串，按位存储信息，用于统计签到次数，日活等等
### 持久化策略
**RDB持久化**是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据快照写入磁盘中，它是Redis默认的持久化方式。执行完操作后，在指定目录下会生成一个dump.rdb文件，Redis 重启的时候，通过加载dump.rdb文件来恢复数据。
bgsave是主流的触发 RDB 持久化的方式，执行过程如下：

1. 执行BGSAVE命令 
2. Redis 父进程判断当前是否存在正在执行的子进程，如果存在，BGSAVE命令直接返回。 
3. 父进程执行fork操作创建子进程，fork操作过程中父进程会阻塞。 
4. 父进程fork完成后，父进程继续接收并处理客户端的请求**，而**子进程开始将内存中的数据写进硬盘的临时文件； 
5. 当子进程写完所有数据后会用该临时文件替换旧的 RDB 文件。

Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。RDB持久化存在问题是不能实时持久化/秒级持久化、新老版本存在RDB格式兼容问题。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484535430-5d9ecfcd-41f7-4b2b-9366-eb88d05b9756.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=282&id=uf8bebc73&name=image.png&originHeight=848&originWidth=1238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=332322&status=done&style=none&taskId=ud35afa86-c746-4c99-8691-08631c196fd&title=&width=412)
**AOF持久化**
AOF（append only file）持久化，采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。

1. 所有的写入命令会追加到 AOP 缓冲区中。 
2. AOF 缓冲区根据对应的策略向硬盘同步。 
3. 随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。 
4. 当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。

AOF的缺点是AOF记录的内容越多，文件越大，数据恢复变慢。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484630486-c56ace5f-e911-48e0-9ac1-be0fa0484adf.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=350&id=u24621c9a&name=image.png&originHeight=700&originWidth=524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149138&status=done&style=none&taskId=u19e7c554-d8bd-4c7c-907c-b75c9bfe698&title=&width=262)
### Redis和DB的数据一致性问题
#### 旁路缓存
旁路缓冲适合读请求比较多的情景。
**对于写数据：先更新DB，然后直接删除缓存。**

1. **写数据过程中，可以先删除cache后更新DB吗？**肯定是不行的，会造成数据库和缓存数据不一致问题。比如请求1先把cache中的A数据删除—>请求2从DB中读取数据—>请求1再把DB中的A数据更新。
2. **写数据过程中，先更新DB后删除cache就没有问题了吗?**理论上来说还是可能会出现数据不一致的问题，不过概率非常小，因为缓存写入速度比数据写入速度快很多！比如：请求1从DB读数据A—>请求2写更新数据A到数据库并删除缓存中的A数据—>请求1将数据A写入cache。

**对于读数据：**从cache中读取数据，读取到就直接返回。读取不到就去DB中读，写入到缓存返回数据。

1. **对于首次请求数据一定不在cache的问题**，可以将热点数据提取放到cache中
2. **写操作频繁的话导致cache中的数据会被频繁删除，影响命中率？**
解决方法：对于数据库和缓存数据强一致性场景：更新DB同时更新cache。不过需要加一个锁/分布式锁来保证更新cache的时不存在线程安全问题
3. **对于短暂地允许DB和cache不一致的场景**：更新DB时同样更新cache，但是给缓存加一个比较短的过期时间，这也就可以保证即使数据不一致的话影响也比较小
#### 读写穿透
读写穿透中服务端把cache视为主要数据存储，从中读取数据并将数据写入其中。cache服务负责将此数据读取和写入DB，从而减轻应用程序的职责。
**对于写数据**：先查cache，cache不存在，直接更新DB- cache中存在，则先更新cache，然后cache服务自己更新DB。
**对于读数据**：从cache中读取数据，读取到就直接返回。读取不到就去DB中读，则先从DB加载写入到缓存返回数据。
#### 异步缓存
异步缓存写入和读写穿透很相似，两者都是由cache服务来负责cache和DB的读写。
两者最大的不同点是：读写穿透是同步更新DB和cache，而异步缓存写入则是只更新cache，不直接更新DB，而是改为异步批量的方式更新DB。很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB，cache服务可能就挂了。
这种策略在我们平时开发过程中也非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL的InnoDB Buffer Pool机制都用到了这种策略。
异步缓存写入的写性能非常高，非常适合写数据经常变化又对数据一致性要求没那么高的场景下使用，比如浏览量、点赞量等。
### 缓存问题
**缓存雪崩：**当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。
**缓存击穿**：如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。解决方法：

- 采用互斥锁，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；

**缓存穿透：**当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661486163530-7d412512-5396-437d-b5e9-be2efd0a7d3b.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=311&id=oKO9D&name=image.png&originHeight=622&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204754&status=done&style=none&taskId=u6cc1539a-0d6d-47f9-b040-613683189a7&title=&width=540)
### 过期键的删除策略
每当设置一个键的过期时间时，redis就会从过期字典中检测是否存在，存在则获取过期时间，然后用过期时间和当前系统时间进行比对，比系统时间大则没有过期，反之过期。redis过期键的删除策略是惰性删除和定期删除两种策略配合使用
```bash
expire key time // key的过期时间是time秒
```
**定时删除：**设置过期时间，创建定时器，定时器到了过期时间后立即执行删除操作。对内存优化，用完就删了。对cpu不友好，过期键多的时候，删除会占cpu时间，对服务器响应和吞吐量有影响。
**惰性删除：**设置过期时间不管他，等用的时候看是否过期了，过期就执行删除。对cpu友好。对内存不友好，可能造成内存泄漏。
**定期删除：**每隔一段时间对一些key检查，删除里面过期的key。
优点：

- 可以限制删除操作执行的时长和频率来减少删除操作对cpu的影响
- 定期删除也能有效的释放过期键占用的内存

缺点：

- 难以确定删除操作的时长和频，太频繁和定时删除一样了，太少和惰性删除一样了。
- 再获取某个键时，某个键的过期时间到了但还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。
### 内存淘汰策略
当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器正常运行。
**Redisv4.0前提供 6 种数据淘汰策略**：

- **volatile-lru**：LRU（Least Recently Used），最近使用。利用LRU算法移除设置了过期时间的key
- **allkeys-lru**：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的key
- **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰
- **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰
- **allkeys-random**：从数据集中任意选择数据淘汰
- **no-eviction**：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错
**Redisv4.0后增加以下两种**：
- **volatile-lfu**：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
- **allkeys-lfu**：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的key。
**内存淘汰策略可以通过配置文件来修改**，相应的配置项是maxmemory-policy，默认配置是noeviction。
### 分布式锁
SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁。如果 key 不存在，则显示插入成功，可以用来表示加锁成功；如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
一般而言，还会对分布式锁加上过期时间，分布式锁命令如下：
```bash
// NX代表只在lock_ key不存在时，才对lock_ key进行设置操作；
// PX 10000表示设置lock_ key的过期时间为10s，这是为了避免客户端发生异常而无法释放锁。
SET lock_key unique_value NX PX 10000
```
解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以解锁的时候，先判断锁的 unique_value是否为加锁客户端，是的话，才将lock_key键删除。
```bash
// 释放锁时，先比较unique_value是否相等，避免锁的误释放
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
```
解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。
这样做存在一个问题，如果规定时间内该线程并没有结束，却释放了锁怎么办？
可以使用一个守护线程，定时检查任务是否完成，如果没有完成，为锁续命
```bash
// 为锁续命3秒
expire lock 3
```
redis分布式锁遇到的问题及解决方法：

- 死锁：设置过期时间
- 过期时间评估不好，锁提前过期：守护线程，自动续期
- 锁被别人释放：锁写入唯一标识，释放锁先检查标识，再释放

上面的实现方式还存在一个问题，就是如果设置了锁之后，主节点宕机，而从节点恰好也没有同步到这个锁，那么就会导致锁丢失的问题，引起线程安全问题。
##### RedLock(红锁)
RedLock加锁过程：

1. 客户端先获取「当前系统时间戳T1」
2. 客户端依次向**多个**(至少5个) Redis 实例发起加锁请求，且每个请求都会设置超时时间（毫秒级，要远小于锁的有效时间），如果某一个实例加锁失败（网络超时、锁被其它人持有等异常情况），就立即向下一个 Redis 实例申请加锁
3. 如果客户端在**大多数**（n / 2 + 1，这里为3） Redis 实例加锁成功，则再次获取「当前系统时间戳T2」，如果 T2 - T1 < 锁的过期时间，认为客户端加锁成功，否则认为加锁失败
4. 加锁成功，去操作共享资源（如修改 MySQL 某一行或发起一个 API 请求）
5. 加锁失败，向**全部节点**发起释放锁请求（Lua 脚本释放锁）。

**为什么要在多个实例上加锁？**本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用。 
**为什么大多数加锁成功，才算成功？**在分布式系统中，总会出现异常节点，如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的。 
**为什么加锁成功后，还要计算加锁的累计耗时？**因为操作的是多个节点，所以耗时肯定会比操作单个实例耗时更长，而且网络可能存在延迟、丢包、超时等情况发生，网络请求越多，异常发生的概率就越大。所以，即使大多数节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁就没有意义了。 
**为什么释放锁，要操作所有节点？**防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁 
##### Zookeeper实现分布式锁
zk是一个小型文件管理系统。
临时节点：客户端1尝试创建临时节点znode，此时创建成功了就获取了这个锁；这个时候客户端2来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。
顺序节点：多个客户端排队获取锁，最前面的客户端先获取到锁执行任务，然后释放锁；后面的每个客户端都会去监听排在自己前面的那个客户端创建的node 。一旦某个客户端释放了锁，后面的客户端就会收到 ZooKeeper 的通知，自己就获取到了锁，就可以执行代码了。
存在问题：zk 依靠 session 定期的心跳来维持客户端，如果客户端进入长时间的 GC，可能会导致 zk 认为客户端宕机而释放锁，让其他的客户端获取锁，但是客户端在 GC 恢复后，会认为自己还持有锁，从而可能出现多个客户端同时获取到锁的情形。可以通过 JVM 调优，尽量避免长时间 GC 的情况发生。
### 部署模式
**单机模式：**只使用一个redis服务器。特点就是简单，但存在问题是内存容量有限、处理能力有限、无法高可用。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484689455-44c56b23-e505-4130-a222-722d10677200.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=u7eadc720&name=image.png&originHeight=241&originWidth=426&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54583&status=done&style=none&taskId=uff4eaaaa-3979-488d-a3cb-7a46ce881f1&title=&width=284)
**主从复制模式：**一主多从（读写分离）主机负责写操作，并将数据同步给其他从节点，从机负责读操作，从而实现
高并发。特点是将读的压力从主库转到从库。
![](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484731145-3ebb7a2d-777d-4101-bd2b-b0492622c7d7.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&height=227&id=atzas&originHeight=355&originWidth=462&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7f68773b-cf7a-4cae-b400-89bc4f15e24&title=&width=296)
存在问题：无法保证高可用。没有解决主库写的压力。
**哨兵模式**是建立在主从模式之上。可以监控主从服务器，并在主服务器下线时自动进行故障转移。
![](https://cdn.nlark.com/yuque/0/2022/png/26499320/1661484816093-f6852deb-ed13-4b0d-b478-59d8598d37f4.png#clientId=ue0a7919a-f6e9-4&crop=0&crop=0&crop=1&crop=1&height=228&id=gDnd5&originHeight=401&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucd3d3c49-0946-4f6c-87de-7907b7d2f00&title=&width=249)

- 监控： 不断检查主服务器和从服务器的工作状态是否正常
- 提醒：当被监控的某个服务器出现问题时，哨兵 可以通过API向管理员或者其他的应用程序发送通知。
- 自动故障迁移：当一个主服务器不能正常工作时，哨兵会开始自动故障迁移操作。

特点：

1. 可以保证高可用性
2. 可以监控各个节点
3. 自动故障迁移

**问题：**没有解决主服务器的写压力问题


